{"slug":"merge-sort","title":"Merge Sort","description":"The Merge Sort algorithm is a sorting algorithm that is considered an example of the divide and conquer strategy. So, in this algorithm, the array is initially divided into two equal halves and then they are combined in a sorted manner.","image":"https://raw.githubusercontent.com/codinasion/codinasion/master/image/og/default.png","tags":["c","cpp","js"],"contributors":["KacperTKI","mobo07","curious0207"],"latestUpdateDate":"2022-08-15T09:07:25Z","contentHtml":"<h2>Merge Sort</h2>\n<p>The <strong>Merge Sort</strong> algorithm is a sorting algorithm that is considered an example of the divide and conquer strategy. So, in this algorithm, the array is initially divided into two equal halves and then they are combined in a sorted manner. We can think of it as a recursive algorithm that continuously splits the array in half until it cannot be further divided. This means that if the array becomes empty or has only one element left, the dividing will stop, i.e. it is the base case to stop the recursion. If the array has multiple elements, we split the array into halves and recursively invoke the merge sort on each of the halves. Finally, when both the halves are sorted, the merge operation is applied. Merge operation is the process of taking two smaller sorted arrays and combining them to eventually make a larger one.</p>\n<pre><code>Input  : 5 4 1 6 2\nOutput : 1 2 4 5 6\n</code></pre>\n<pre><code>Time Complexity : O(n logn)\n</code></pre>\n<pre><code>Space Complexity : O(n)\n</code></pre>\n<hr>\n<pre><code>// Write a programme for merge sort\n#include &#x3C;iostream>\n\nusing namespace std;\n\nvoid PrintArray(int *arr, int size);\nvoid MergeSort(int *arr, int leftIndex, int rightIndex);\n\nint main()\n{\n    int array[] = {5, 4, 1, 6, 2};\n    int size = sizeof(array) / sizeof(array[0]);\n    cout &#x3C;&#x3C; \"Before sorting : \";\n    PrintArray(array, size);\n\n    MergeSort(array, 0, size - 1);\n\n    cout &#x3C;&#x3C; \"After  sorting : \";\n    PrintArray(array, size);\n\n    return 0;\n}\n\nvoid PrintArray(int *arr, int size)\n{\n    for (int i = 0; i &#x3C; size; i++)\n    {\n        cout &#x3C;&#x3C; arr[i] &#x3C;&#x3C; \" \";\n    }\n    cout &#x3C;&#x3C; '\\n';\n}\n\nvoid Merge(int *arr, int leftIndex, int middle, int rightIndex)\n{\n    // get the sizes of the two auxiliary arrays\n    const int subArrSize1 = middle - leftIndex + 1;\n    const int subArrSize2 = rightIndex - middle;\n\n    // reserve the memory for the two auxiliary arrays\n    int *subArr1 = new int[subArrSize1];\n    int *subArr2 = new int[subArrSize2];\n\n    // copy the values of the left side array into the auxiliary array\n    int j = 0;\n    for (int i = leftIndex; i &#x3C;= middle; i++)\n    {\n        subArr1[j++] = arr[i];\n    }\n    // copy the values of the right side array into the auxiliary array\n    int p = 0;\n    for (int i = middle + 1; i &#x3C;= rightIndex; i++)\n    {\n        subArr2[p++] = arr[i];\n    }\n\n    // move the values from the auxiliary arrays to the main array\n    j = 0;\n    p = 0;\n    for (int i = leftIndex; i &#x3C;= rightIndex; i++)\n    {\n        // check if both arrays are still being checked\n        if (j &#x3C; subArrSize1 &#x26;&#x26; p &#x3C; subArrSize2)\n        {\n            // if so, then check which value is smaller\n            if (subArr1[j] &#x3C; subArr2[p])\n            {\n                arr[i] = subArr1[j++];\n            }\n            else\n            {\n                arr[i] = subArr2[p++];\n            }\n        }\n        // if one array is out of bounds, merge the values from the one, which is not out of bounds\n        else if (j &#x3C; subArrSize1 &#x26;&#x26; p >= subArrSize2)\n        {\n            arr[i] = subArr1[j++];\n        }\n        else\n        {\n            arr[i] = subArr2[p++];\n        }\n    }\n\n    // free the space on the heap\n    delete[] subArr1;\n    delete[] subArr2;\n}\n\nvoid MergeSort(int *arr, int leftIndex, int rightIndex)\n{\n    // check if the array has been divided until only one value is left\n    if (leftIndex >= rightIndex)\n        return;\n\n    int middle = (leftIndex + rightIndex) / 2; // get the middle of the array\n\n    // divide the left and right side array again\n    MergeSort(arr, leftIndex, middle);\n    MergeSort(arr, middle + 1, rightIndex);\n    // after we divided the array, merge the parts together\n    Merge(arr, leftIndex, middle, rightIndex);\n}\n\n</code></pre>\n<pre><code>// Merge Sort  Time complexity: O(n*logn) , Space complexity: O(n).\n#include&#x3C;stdio.h>\nvoid mergearray(int arr[],int low,int mid,int high){\n    int s1=mid-low+1;\n    int s2=high-mid;\n    int L[s1],R[s2];   \n    for(int i=0;i&#x3C;s1;i++){\n        L[i]=arr[low+i];\n    }\n    for(int i=0;i&#x3C;s2;i++){\n        R[i]=arr[mid+1+i];\n    }                              // L,R left and right sorted arrays\n    int i=0,j=0,k=low;\n    while(i&#x3C;s1&#x26;&#x26;j&#x3C;s2){\n        if(L[i]&#x3C;R[j]){\n            arr[k]=L[i];\n            i++;\n        }\n        else{\n            arr[k]=R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while(i&#x3C;s1){\n        arr[k]=L[i];\n        i++;\n        k++;\n    }\n    while(j&#x3C;s2){\n        arr[k]=R[j];\n        j++;\n        k++;\n    }\n}\nvoid mergesort(int arr[],int low,int high){\n    if(high>low){\n        int mid=low+(high-low)/2;\n        mergesort(arr,low,mid);\n        mergesort(arr,mid+1,high);\n        mergearray(arr,low,mid,high);\n    }\n}\nint main(){\n    int arr[]={5,4,1,6,2};\n    int l=0;\n    int n=sizeof(arr)/sizeof(arr[0]);\n    int h=n-1;\n    printf(\"Input : \");\n    for(int i=0;i&#x3C;n;i++){\n        printf(\"%d \",arr[i]);\n    }\n    printf(\"\\n\");\n    mergesort(arr,l,h);\n    printf(\"Output : \");\n    for(int i=0;i&#x3C;n;i++){\n        printf(\"%d \",arr[i]);\n    }\n    return 0;\n}\n\n</code></pre>\n<pre><code>//Function to merge the arrays split between left and right\r\nconst merge = (left, right) => {\r\n  const sortedArr = [];\r\n  //If the length of the left and right array is > 0 then the while loop continues\r\n  while (left.length &#x26;&#x26; right.length) {\r\n    //Compare the first left and right values on each loop and push the smaller value in sortedArr\r\n    if (left[0] &#x3C; right[0]) {\r\n      sortedArr.push(left.shift());\r\n    } else {\r\n      sortedArr.push(right.shift());\r\n    }\r\n  }\r\n  //Spread the values for left and right in case of remnants\r\n  return [...sortedArr, ...left, ...right];\r\n};\r\n\r\nconst mergeSort = (arr) => {\r\n  //Return the array if there is 1 or no element contained\r\n  if (arr.length &#x3C;= 1) return arr;\r\n\r\n  //Getthe mid point of the array and divide the array in half\r\n  const mid = Math.floor(arr.length / 2);\r\n  const left = arr.splice(0, mid);\r\n  const right = arr;\r\n\r\n  //Call original function (mergeSort) recursively until 1 or no element is left in left and right array\r\n  return merge(mergeSort(left), mergeSort(right));\r\n};\r\n\r\nconst unsorted = [8, 32, 9, 1, 5, 10, 7];\r\nconst sorted = mergeSort(unsorted);\r\n\r\nconsole.log(sorted);\r\n\n</code></pre>\n","markdown":"\n## Merge Sort\n\nThe **Merge Sort** algorithm is a sorting algorithm that is considered an example of the divide and conquer strategy. So, in this algorithm, the array is initially divided into two equal halves and then they are combined in a sorted manner. We can think of it as a recursive algorithm that continuously splits the array in half until it cannot be further divided. This means that if the array becomes empty or has only one element left, the dividing will stop, i.e. it is the base case to stop the recursion. If the array has multiple elements, we split the array into halves and recursively invoke the merge sort on each of the halves. Finally, when both the halves are sorted, the merge operation is applied. Merge operation is the process of taking two smaller sorted arrays and combining them to eventually make a larger one.\n\n```txt\nInput  : 5 4 1 6 2\nOutput : 1 2 4 5 6\n```\n\n```txt\nTime Complexity : O(n logn)\n```\n\n```txt\nSpace Complexity : O(n)\n```\n\n---\n\n\n<CodeBlock>\n        \n```cpp\n// Write a programme for merge sort\n#include <iostream>\n\nusing namespace std;\n\nvoid PrintArray(int *arr, int size);\nvoid MergeSort(int *arr, int leftIndex, int rightIndex);\n\nint main()\n{\n    int array[] = {5, 4, 1, 6, 2};\n    int size = sizeof(array) / sizeof(array[0]);\n    cout << \"Before sorting : \";\n    PrintArray(array, size);\n\n    MergeSort(array, 0, size - 1);\n\n    cout << \"After  sorting : \";\n    PrintArray(array, size);\n\n    return 0;\n}\n\nvoid PrintArray(int *arr, int size)\n{\n    for (int i = 0; i < size; i++)\n    {\n        cout << arr[i] << \" \";\n    }\n    cout << '\\n';\n}\n\nvoid Merge(int *arr, int leftIndex, int middle, int rightIndex)\n{\n    // get the sizes of the two auxiliary arrays\n    const int subArrSize1 = middle - leftIndex + 1;\n    const int subArrSize2 = rightIndex - middle;\n\n    // reserve the memory for the two auxiliary arrays\n    int *subArr1 = new int[subArrSize1];\n    int *subArr2 = new int[subArrSize2];\n\n    // copy the values of the left side array into the auxiliary array\n    int j = 0;\n    for (int i = leftIndex; i <= middle; i++)\n    {\n        subArr1[j++] = arr[i];\n    }\n    // copy the values of the right side array into the auxiliary array\n    int p = 0;\n    for (int i = middle + 1; i <= rightIndex; i++)\n    {\n        subArr2[p++] = arr[i];\n    }\n\n    // move the values from the auxiliary arrays to the main array\n    j = 0;\n    p = 0;\n    for (int i = leftIndex; i <= rightIndex; i++)\n    {\n        // check if both arrays are still being checked\n        if (j < subArrSize1 && p < subArrSize2)\n        {\n            // if so, then check which value is smaller\n            if (subArr1[j] < subArr2[p])\n            {\n                arr[i] = subArr1[j++];\n            }\n            else\n            {\n                arr[i] = subArr2[p++];\n            }\n        }\n        // if one array is out of bounds, merge the values from the one, which is not out of bounds\n        else if (j < subArrSize1 && p >= subArrSize2)\n        {\n            arr[i] = subArr1[j++];\n        }\n        else\n        {\n            arr[i] = subArr2[p++];\n        }\n    }\n\n    // free the space on the heap\n    delete[] subArr1;\n    delete[] subArr2;\n}\n\nvoid MergeSort(int *arr, int leftIndex, int rightIndex)\n{\n    // check if the array has been divided until only one value is left\n    if (leftIndex >= rightIndex)\n        return;\n\n    int middle = (leftIndex + rightIndex) / 2; // get the middle of the array\n\n    // divide the left and right side array again\n    MergeSort(arr, leftIndex, middle);\n    MergeSort(arr, middle + 1, rightIndex);\n    // after we divided the array, merge the parts together\n    Merge(arr, leftIndex, middle, rightIndex);\n}\n\n```\n                \n```c\n// Merge Sort  Time complexity: O(n*logn) , Space complexity: O(n).\n#include<stdio.h>\nvoid mergearray(int arr[],int low,int mid,int high){\n    int s1=mid-low+1;\n    int s2=high-mid;\n    int L[s1],R[s2];   \n    for(int i=0;i<s1;i++){\n        L[i]=arr[low+i];\n    }\n    for(int i=0;i<s2;i++){\n        R[i]=arr[mid+1+i];\n    }                              // L,R left and right sorted arrays\n    int i=0,j=0,k=low;\n    while(i<s1&&j<s2){\n        if(L[i]<R[j]){\n            arr[k]=L[i];\n            i++;\n        }\n        else{\n            arr[k]=R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while(i<s1){\n        arr[k]=L[i];\n        i++;\n        k++;\n    }\n    while(j<s2){\n        arr[k]=R[j];\n        j++;\n        k++;\n    }\n}\nvoid mergesort(int arr[],int low,int high){\n    if(high>low){\n        int mid=low+(high-low)/2;\n        mergesort(arr,low,mid);\n        mergesort(arr,mid+1,high);\n        mergearray(arr,low,mid,high);\n    }\n}\nint main(){\n    int arr[]={5,4,1,6,2};\n    int l=0;\n    int n=sizeof(arr)/sizeof(arr[0]);\n    int h=n-1;\n    printf(\"Input : \");\n    for(int i=0;i<n;i++){\n        printf(\"%d \",arr[i]);\n    }\n    printf(\"\\n\");\n    mergesort(arr,l,h);\n    printf(\"Output : \");\n    for(int i=0;i<n;i++){\n        printf(\"%d \",arr[i]);\n    }\n    return 0;\n}\n\n```\n                \n```js\n//Function to merge the arrays split between left and right\r\nconst merge = (left, right) => {\r\n  const sortedArr = [];\r\n  //If the length of the left and right array is > 0 then the while loop continues\r\n  while (left.length && right.length) {\r\n    //Compare the first left and right values on each loop and push the smaller value in sortedArr\r\n    if (left[0] < right[0]) {\r\n      sortedArr.push(left.shift());\r\n    } else {\r\n      sortedArr.push(right.shift());\r\n    }\r\n  }\r\n  //Spread the values for left and right in case of remnants\r\n  return [...sortedArr, ...left, ...right];\r\n};\r\n\r\nconst mergeSort = (arr) => {\r\n  //Return the array if there is 1 or no element contained\r\n  if (arr.length <= 1) return arr;\r\n\r\n  //Getthe mid point of the array and divide the array in half\r\n  const mid = Math.floor(arr.length / 2);\r\n  const left = arr.splice(0, mid);\r\n  const right = arr;\r\n\r\n  //Call original function (mergeSort) recursively until 1 or no element is left in left and right array\r\n  return merge(mergeSort(left), mergeSort(right));\r\n};\r\n\r\nconst unsorted = [8, 32, 9, 1, 5, 10, 7];\r\nconst sorted = mergeSort(unsorted);\r\n\r\nconsole.log(sorted);\r\n\n```\n                \n</CodeBlock>\n          \n        "}