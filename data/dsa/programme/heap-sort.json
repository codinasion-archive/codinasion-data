{"slug":"heap-sort","title":"Heap Sort","description":"Heap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to the selection sort where we first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements. Heap sort is an in-place algorithm.","image":"https://raw.githubusercontent.com/codinasion/codinasion-dsa/master/programme/heap-sort/heap-sort.png","tags":["cpp","py"],"contributors":["Peleg-Noam","KacperTKI"],"latestUpdateDate":"2022-08-06T13:56:14Z","contentHtml":"<h2>Heap Sort</h2>\n<p>Heap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to the selection sort where we first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements. Heap sort is an in-place algorithm.</p>\n<pre><code>Input  : 20 10 30 60 40\nOutput : 10 20 30 40 60\n</code></pre>\n<pre><code>Time Complexity : O(n Log n)\n</code></pre>\n<pre><code>Space Complexity : O(1)\n</code></pre>\n<hr>\n<pre><code>from heapq import heapify\n\ndef heapify(arr, length, r):\n    largest = r\n    left = (r * 2) + 1\n    right = (r * 2) + 2\n\n    # check if left child is larger than root\n    if left &#x3C; length and arr[r] &#x3C; arr[left]:\n        largest = left\n\n    # check if right child is larger than root\n    if right &#x3C; length and arr[largest] &#x3C; arr[left]:\n        largest = right\n\n    if largest != r:\n        arr[r], arr[largest] = arr[largest], arr[r] # swap both\n        heapify(arr, r, largest) # recursive\n\n\ndef heap_sort(arr):\n    length = len(arr)\n\n    # create max heap binary tree (root is largest) from array\n    for r in range(length//2, -1, -1):\n        heapify(arr, length, r) # r is the size of the heap tree\n    \n    for r in range(length - 1, 0, -1):\n        arr[r], arr[0] = arr[0], arr[r] #swap both\n        heapify(arr, r, 0)\n\narr = [5, 4, 1, 6, 2]\nprint(\"Input  : \" + ' '.join(str(num) for num in arr)) # turn all numbers into strings, join them together and print\n\nheap_sort(arr) # do heap sort\nprint(\"Output : \" + ' '.join(str(num) for num in arr)) # turn all numbers into strings, join them together and print\n</code></pre>\n<pre><code>#include &#x3C;iostream>\n#include &#x3C;cmath> // for floor()\n\nvoid PrintArray(int *arr, int size);\nvoid HeapSort(int *arr, int n);\n\nint main() {\n    int array[] = { 5, 4, 1, 6, 2 };\n    int size = sizeof(array) / sizeof(array[0]);\n    PrintArray(array, size);\n    \n    HeapSort(array, size);\n    PrintArray(array, size);\n    \n    return 0;\n}\n\nvoid PrintArray(int *arr, int size) {\n    for (int i = 0; i &#x3C; size; i++) {\n        std::cout &#x3C;&#x3C; arr[i] &#x3C;&#x3C; \" \";\n    }\n    std::cout &#x3C;&#x3C; '\\n';\n}\n\nvoid Swap(int *arr, int index1, int index2) {\n    int tmp = arr[index1];\n    arr[index1] = arr[index2];\n    arr[index2] = tmp;\n}\n\nvoid Heapify(int *arr, int n, int i) {\n    int left = i * 2 + 1;\n    int right = (i * 2) + 2;\n    \n    int max = i;\n    \n    // check if the left node exists and if so, then check if it's a bigger value\n    if (left &#x3C; n &#x26;&#x26; arr[left] > arr[max]) {\n        max = left; // if the left node has a bigger value, then update the max index\n    }\n    \n    // check if the right node exists and if so, then check if it's a bigger value\n    if (right &#x3C; n &#x26;&#x26; arr[right] > arr[max]) {\n        max = right; // if the right node has a bigger value, then update the max index\n    }\n    \n    if (max != i) {\n        // if max is not the root, we swap places and make it one\n        Swap(arr, i, max);\n        Heapify(arr, n, max);\n    }\n}\n\nvoid BuildMaxHeap(int *arr, int n) {\n    // go through the remaining nodes of the tree and run heapify on each one\n    for (int i = floor(n / 2) + 1; i >= 0; i--) {\n        Heapify(arr, n, i);\n    }\n}\n\nvoid HeapSort(int *arr, int n) {\n    // build the binary heap\n    BuildMaxHeap(arr, n);\n\n    for (int i = n - 1; i >= 0; i--) {\n        // move the current root to the end\n        Swap(arr, 0, i);\n        // heapify the binary heap without the end nodes, since they are in the right place\n        Heapify(arr, i, 0);\n    }\n}\n</code></pre>\n","markdown":"\n## Heap Sort\n\nHeap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to the selection sort where we first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements. Heap sort is an in-place algorithm. \n\n\n```txt\nInput  : 20 10 30 60 40\nOutput : 10 20 30 40 60\n```\n\n```txt\nTime Complexity : O(n Log n)\n```\n\n```txt\nSpace Complexity : O(1)\n```\n\n---\n\n\n<CodeBlock>\n        \n```python\nfrom heapq import heapify\n\ndef heapify(arr, length, r):\n    largest = r\n    left = (r * 2) + 1\n    right = (r * 2) + 2\n\n    # check if left child is larger than root\n    if left < length and arr[r] < arr[left]:\n        largest = left\n\n    # check if right child is larger than root\n    if right < length and arr[largest] < arr[left]:\n        largest = right\n\n    if largest != r:\n        arr[r], arr[largest] = arr[largest], arr[r] # swap both\n        heapify(arr, r, largest) # recursive\n\n\ndef heap_sort(arr):\n    length = len(arr)\n\n    # create max heap binary tree (root is largest) from array\n    for r in range(length//2, -1, -1):\n        heapify(arr, length, r) # r is the size of the heap tree\n    \n    for r in range(length - 1, 0, -1):\n        arr[r], arr[0] = arr[0], arr[r] #swap both\n        heapify(arr, r, 0)\n\narr = [5, 4, 1, 6, 2]\nprint(\"Input  : \" + ' '.join(str(num) for num in arr)) # turn all numbers into strings, join them together and print\n\nheap_sort(arr) # do heap sort\nprint(\"Output : \" + ' '.join(str(num) for num in arr)) # turn all numbers into strings, join them together and print\n```\n                \n```cpp\n#include <iostream>\n#include <cmath> // for floor()\n\nvoid PrintArray(int *arr, int size);\nvoid HeapSort(int *arr, int n);\n\nint main() {\n    int array[] = { 5, 4, 1, 6, 2 };\n    int size = sizeof(array) / sizeof(array[0]);\n    PrintArray(array, size);\n    \n    HeapSort(array, size);\n    PrintArray(array, size);\n    \n    return 0;\n}\n\nvoid PrintArray(int *arr, int size) {\n    for (int i = 0; i < size; i++) {\n        std::cout << arr[i] << \" \";\n    }\n    std::cout << '\\n';\n}\n\nvoid Swap(int *arr, int index1, int index2) {\n    int tmp = arr[index1];\n    arr[index1] = arr[index2];\n    arr[index2] = tmp;\n}\n\nvoid Heapify(int *arr, int n, int i) {\n    int left = i * 2 + 1;\n    int right = (i * 2) + 2;\n    \n    int max = i;\n    \n    // check if the left node exists and if so, then check if it's a bigger value\n    if (left < n && arr[left] > arr[max]) {\n        max = left; // if the left node has a bigger value, then update the max index\n    }\n    \n    // check if the right node exists and if so, then check if it's a bigger value\n    if (right < n && arr[right] > arr[max]) {\n        max = right; // if the right node has a bigger value, then update the max index\n    }\n    \n    if (max != i) {\n        // if max is not the root, we swap places and make it one\n        Swap(arr, i, max);\n        Heapify(arr, n, max);\n    }\n}\n\nvoid BuildMaxHeap(int *arr, int n) {\n    // go through the remaining nodes of the tree and run heapify on each one\n    for (int i = floor(n / 2) + 1; i >= 0; i--) {\n        Heapify(arr, n, i);\n    }\n}\n\nvoid HeapSort(int *arr, int n) {\n    // build the binary heap\n    BuildMaxHeap(arr, n);\n\n    for (int i = n - 1; i >= 0; i--) {\n        // move the current root to the end\n        Swap(arr, 0, i);\n        // heapify the binary heap without the end nodes, since they are in the right place\n        Heapify(arr, i, 0);\n    }\n}\n```\n                \n</CodeBlock>\n          \n        "}