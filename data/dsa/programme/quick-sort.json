{"slug":"quick-sort","title":"Quick Sort","description":"QuickSort is a Divide and Conquer algorithm. It picks an element as pivot, and then it partitions the given array around the picked pivot element. In quick sort, a large array is divided into two arrays in which one holds values that are smaller than the specified value (Pivot), and another array holds the values that are greater than the pivot. After that, left and right sub-arrays are also partitioned using the same approach. It will continue until the single element remains in the sub-array.","image":"https://raw.githubusercontent.com/codinasion/codinasion-dsa/master/programme/quick-sort/quick-sort.png","tags":["c"],"contributors":["anirudhhkashyap"],"latestUpdateDate":"2022-07-26T13:42:12Z","contentHtml":"<h2>Quick Sort</h2>\n<p>QuickSort is a Divide and Conquer algorithm. It picks an element as pivot, and then it partitions the given array around the picked pivot element. In quick sort, a large array is divided into two arrays in which one holds values that are smaller than the specified value (Pivot), and another array holds the values that are greater than the pivot.</p>\n<p>After that, left and right sub-arrays are also partitioned using the same approach. It will continue until the single element remains in the sub-array.</p>\n<pre><code>Input  : 10 80 30 90 40 50 70\nOutput : 10 30 40 50 70 80 90\n</code></pre>\n<pre><code>Time Complexity : O(n*logn)\n</code></pre>\n<pre><code>Space Complexity : O(n)\n</code></pre>\n<hr>\n<pre><code>// Write a programme for quick sort\n#include &#x3C;stdio.h>\n\n// Utility function to swap array elements\nvoid swap(int a[], int i, int j)\n{\n  int t = a[i];\n  a[i] = a[j];\n  a[j] = t;\n}\n\nint partition(int arr[], int start, int end)\n{\n  // initialise last element as pivot\n  int x = arr[end];\n  int i = start - 1, temp;\n\n  for (int j = start; j &#x3C;= end - 1; j++)\n  {\n    // if current element is smaller than pivot\n    if (arr[j] &#x3C; x)\n    {\n      // increment index of smaller element\n      i++;\n      swap(arr, i, j);\n    }\n  }\n  swap(arr, i + 1, end);\n\n  return i + 1;\n}\n\nvoid qs(int a[], int start, int end)\n{\n  if (start > end)\n    return;\n\n  int pivot = partition(a, start, end);\n\n  // Sorts elements before the pivot and after the pivot separately\n  qs(a, start, pivot - 1);\n  qs(a, pivot + 1, end);\n}\n\nvoid quickSort(int input[], int size)\n{\n\n  qs(input, 0, size - 1);\n\n  // Prints the sorted array\n  for (int i = 0; i &#x3C; size; i++)\n    printf(\"%d \", input[i]);\n\n  printf(\"\\n\");\n}\n\nint main()\n{\n  int a[] = {10, 80, 30, 90, 40, 50, 70};\n  printf(\"Input  : \");\n  for (int i = 0; i &#x3C; 7; i++)\n    printf(\"%d \", a[i]);\n  printf(\"\\n\");\n\n  int n = sizeof(a) / sizeof(a[0]);\n  printf(\"Output : \");\n  quickSort(a, n);\n\n  return 0;\n}\n\n</code></pre>\n","markdown":"\n## Quick Sort\n\nQuickSort is a Divide and Conquer algorithm. It picks an element as pivot, and then it partitions the given array around the picked pivot element. In quick sort, a large array is divided into two arrays in which one holds values that are smaller than the specified value (Pivot), and another array holds the values that are greater than the pivot.\n\nAfter that, left and right sub-arrays are also partitioned using the same approach. It will continue until the single element remains in the sub-array.\n\n```txt\nInput  : 10 80 30 90 40 50 70\nOutput : 10 30 40 50 70 80 90\n```\n\n```txt\nTime Complexity : O(n*logn)\n```\n\n```txt\nSpace Complexity : O(n)\n```\n\n---\n\n\n<CodeBlock>\n        \n```c\n// Write a programme for quick sort\n#include <stdio.h>\n\n// Utility function to swap array elements\nvoid swap(int a[], int i, int j)\n{\n  int t = a[i];\n  a[i] = a[j];\n  a[j] = t;\n}\n\nint partition(int arr[], int start, int end)\n{\n  // initialise last element as pivot\n  int x = arr[end];\n  int i = start - 1, temp;\n\n  for (int j = start; j <= end - 1; j++)\n  {\n    // if current element is smaller than pivot\n    if (arr[j] < x)\n    {\n      // increment index of smaller element\n      i++;\n      swap(arr, i, j);\n    }\n  }\n  swap(arr, i + 1, end);\n\n  return i + 1;\n}\n\nvoid qs(int a[], int start, int end)\n{\n  if (start > end)\n    return;\n\n  int pivot = partition(a, start, end);\n\n  // Sorts elements before the pivot and after the pivot separately\n  qs(a, start, pivot - 1);\n  qs(a, pivot + 1, end);\n}\n\nvoid quickSort(int input[], int size)\n{\n\n  qs(input, 0, size - 1);\n\n  // Prints the sorted array\n  for (int i = 0; i < size; i++)\n    printf(\"%d \", input[i]);\n\n  printf(\"\\n\");\n}\n\nint main()\n{\n  int a[] = {10, 80, 30, 90, 40, 50, 70};\n  printf(\"Input  : \");\n  for (int i = 0; i < 7; i++)\n    printf(\"%d \", a[i]);\n  printf(\"\\n\");\n\n  int n = sizeof(a) / sizeof(a[0]);\n  printf(\"Output : \");\n  quickSort(a, n);\n\n  return 0;\n}\n\n```\n                \n</CodeBlock>\n          \n        "}