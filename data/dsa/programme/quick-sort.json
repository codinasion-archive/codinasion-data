{"slug":"quick-sort","title":"Quick Sort","description":"QuickSort is a Divide and Conquer algorithm. It picks an element as pivot, and then it partitions the given array around the picked pivot element. In quick sort, a large array is divided into two arrays in which one holds values that are smaller than the specified value (Pivot), and another array holds the values that are greater than the pivot. After that, left and right sub-arrays are also partitioned using the same approach. It will continue until the single element remains in the sub-array.","image":"https://raw.githubusercontent.com/codinasion/codinasion-dsa/master/programme/quick-sort/quick-sort.png","tags":["c","cpp"],"contributors":["anirudhhkashyap","KacperTKI"],"latestUpdateDate":"2022-07-29T13:26:30Z","contentHtml":"<h2>Quick Sort</h2>\n<p>QuickSort is a Divide and Conquer algorithm. It picks an element as pivot, and then it partitions the given array around the picked pivot element. In quick sort, a large array is divided into two arrays in which one holds values that are smaller than the specified value (Pivot), and another array holds the values that are greater than the pivot.</p>\n<p>After that, left and right sub-arrays are also partitioned using the same approach. It will continue until the single element remains in the sub-array.</p>\n<pre><code>Input  : 10 80 30 90 40 50 70\nOutput : 10 30 40 50 70 80 90\n</code></pre>\n<pre><code>Time Complexity : O(n*logn)\n</code></pre>\n<pre><code>Space Complexity : O(n)\n</code></pre>\n<hr>\n<pre><code>// Write a programme for quick sort\n#include &#x3C;iostream>\n\nvoid swap(int *array, int index1, int index2);\nint partition(int *array, int lowIndex, int highIndex, int pivot);\nvoid quickSort(int *array, int lowIndex, int highIndex);\nvoid printArray(int *array, int size);\n\nint main()\n{\n    int pArray[] = {5, 4, 1, 6, 2};\n    int size = sizeof(pArray) / sizeof(pArray[0]);\n    printf(\"Before Sorting : \");\n    printArray(pArray, size);\n\n    quickSort(pArray, 0, size - 1);\n    printf(\"After  Sorting : \");\n    printArray(pArray, size);\n\n    return 0;\n}\n\nvoid printArray(int *array, int size)\n{\n    for (int i = 0; i &#x3C; size; i++)\n    {\n        std::cout &#x3C;&#x3C; array[i] &#x3C;&#x3C; \" \";\n    }\n    std::cout &#x3C;&#x3C; '\\n';\n}\n\nvoid quickSort(int *array, int lowIndex, int highIndex)\n{\n    // base case for recursion\n    if (lowIndex >= highIndex)\n        return;\n\n    // the pivot is set to the last element\n    int pivot = array[highIndex];\n\n    int pLeft = partition(array, lowIndex, highIndex, pivot);\n\n    // once the pointers have met, we sort the subarrays to the left and right side of the pivot\n    quickSort(array, lowIndex, pLeft - 1);\n    quickSort(array, pLeft + 1, highIndex);\n}\n\nvoid swap(int *array, int index1, int index2)\n{\n    int tmp = array[index1];\n    array[index1] = array[index2];\n    array[index2] = tmp;\n}\n\nint partition(int *array, int lowIndex, int highIndex, int pivot)\n{\n    int pLeft = lowIndex;\n    int pRight = highIndex - 1;\n\n    while (pLeft &#x3C; pRight)\n    {\n        // look for a left pointer, which is bigger than the pivot value\n        // breaks when the right pointer is met as well\n        while (array[pLeft] &#x3C;= pivot &#x26;&#x26; pLeft &#x3C; pRight)\n        {\n            pLeft++;\n        }\n        // look for a right pointer, which is smaller than the pivot value\n        // breaks when the left pointer is met as well\n        while (array[pRight] >= pivot &#x26;&#x26; pRight > pLeft)\n        {\n            pRight--;\n        }\n\n        // swap the elements, so that bigger elements are on the right side of the pivot and the smaller ones on the left\n        swap(array, pLeft, pRight);\n    }\n\n    // this prevents the last element to potentially being out of order\n    if (array[pLeft] > array[highIndex])\n    {\n        // once the pointers meet, then we swap the element with the pivot\n        swap(array, pLeft, highIndex);\n    }\n    else\n    {\n        pLeft = highIndex;\n    }\n\n    // at this point the pivot stands on the index where the left and right pointers met\n    return pLeft;\n}\n\n</code></pre>\n<pre><code>// Write a programme for quick sort\n#include &#x3C;stdio.h>\n\n// Utility function to swap array elements\nvoid swap(int a[], int i, int j)\n{\n  int t = a[i];\n  a[i] = a[j];\n  a[j] = t;\n}\n\nint partition(int arr[], int start, int end)\n{\n  // initialise last element as pivot\n  int x = arr[end];\n  int i = start - 1, temp;\n\n  for (int j = start; j &#x3C;= end - 1; j++)\n  {\n    // if current element is smaller than pivot\n    if (arr[j] &#x3C; x)\n    {\n      // increment index of smaller element\n      i++;\n      swap(arr, i, j);\n    }\n  }\n  swap(arr, i + 1, end);\n\n  return i + 1;\n}\n\nvoid qs(int a[], int start, int end)\n{\n  if (start > end)\n    return;\n\n  int pivot = partition(a, start, end);\n\n  // Sorts elements before the pivot and after the pivot separately\n  qs(a, start, pivot - 1);\n  qs(a, pivot + 1, end);\n}\n\nvoid quickSort(int input[], int size)\n{\n\n  qs(input, 0, size - 1);\n\n  // Prints the sorted array\n  for (int i = 0; i &#x3C; size; i++)\n    printf(\"%d \", input[i]);\n\n  printf(\"\\n\");\n}\n\nint main()\n{\n  int a[] = {10, 80, 30, 90, 40, 50, 70};\n  printf(\"Input  : \");\n  for (int i = 0; i &#x3C; 7; i++)\n    printf(\"%d \", a[i]);\n  printf(\"\\n\");\n\n  int n = sizeof(a) / sizeof(a[0]);\n  printf(\"Output : \");\n  quickSort(a, n);\n\n  return 0;\n}\n\n</code></pre>\n","markdown":"\n## Quick Sort\n\nQuickSort is a Divide and Conquer algorithm. It picks an element as pivot, and then it partitions the given array around the picked pivot element. In quick sort, a large array is divided into two arrays in which one holds values that are smaller than the specified value (Pivot), and another array holds the values that are greater than the pivot.\n\nAfter that, left and right sub-arrays are also partitioned using the same approach. It will continue until the single element remains in the sub-array.\n\n```txt\nInput  : 10 80 30 90 40 50 70\nOutput : 10 30 40 50 70 80 90\n```\n\n```txt\nTime Complexity : O(n*logn)\n```\n\n```txt\nSpace Complexity : O(n)\n```\n\n---\n\n\n<CodeBlock>\n        \n```cpp\n// Write a programme for quick sort\n#include <iostream>\n\nvoid swap(int *array, int index1, int index2);\nint partition(int *array, int lowIndex, int highIndex, int pivot);\nvoid quickSort(int *array, int lowIndex, int highIndex);\nvoid printArray(int *array, int size);\n\nint main()\n{\n    int pArray[] = {5, 4, 1, 6, 2};\n    int size = sizeof(pArray) / sizeof(pArray[0]);\n    printf(\"Before Sorting : \");\n    printArray(pArray, size);\n\n    quickSort(pArray, 0, size - 1);\n    printf(\"After  Sorting : \");\n    printArray(pArray, size);\n\n    return 0;\n}\n\nvoid printArray(int *array, int size)\n{\n    for (int i = 0; i < size; i++)\n    {\n        std::cout << array[i] << \" \";\n    }\n    std::cout << '\\n';\n}\n\nvoid quickSort(int *array, int lowIndex, int highIndex)\n{\n    // base case for recursion\n    if (lowIndex >= highIndex)\n        return;\n\n    // the pivot is set to the last element\n    int pivot = array[highIndex];\n\n    int pLeft = partition(array, lowIndex, highIndex, pivot);\n\n    // once the pointers have met, we sort the subarrays to the left and right side of the pivot\n    quickSort(array, lowIndex, pLeft - 1);\n    quickSort(array, pLeft + 1, highIndex);\n}\n\nvoid swap(int *array, int index1, int index2)\n{\n    int tmp = array[index1];\n    array[index1] = array[index2];\n    array[index2] = tmp;\n}\n\nint partition(int *array, int lowIndex, int highIndex, int pivot)\n{\n    int pLeft = lowIndex;\n    int pRight = highIndex - 1;\n\n    while (pLeft < pRight)\n    {\n        // look for a left pointer, which is bigger than the pivot value\n        // breaks when the right pointer is met as well\n        while (array[pLeft] <= pivot && pLeft < pRight)\n        {\n            pLeft++;\n        }\n        // look for a right pointer, which is smaller than the pivot value\n        // breaks when the left pointer is met as well\n        while (array[pRight] >= pivot && pRight > pLeft)\n        {\n            pRight--;\n        }\n\n        // swap the elements, so that bigger elements are on the right side of the pivot and the smaller ones on the left\n        swap(array, pLeft, pRight);\n    }\n\n    // this prevents the last element to potentially being out of order\n    if (array[pLeft] > array[highIndex])\n    {\n        // once the pointers meet, then we swap the element with the pivot\n        swap(array, pLeft, highIndex);\n    }\n    else\n    {\n        pLeft = highIndex;\n    }\n\n    // at this point the pivot stands on the index where the left and right pointers met\n    return pLeft;\n}\n\n```\n                \n```c\n// Write a programme for quick sort\n#include <stdio.h>\n\n// Utility function to swap array elements\nvoid swap(int a[], int i, int j)\n{\n  int t = a[i];\n  a[i] = a[j];\n  a[j] = t;\n}\n\nint partition(int arr[], int start, int end)\n{\n  // initialise last element as pivot\n  int x = arr[end];\n  int i = start - 1, temp;\n\n  for (int j = start; j <= end - 1; j++)\n  {\n    // if current element is smaller than pivot\n    if (arr[j] < x)\n    {\n      // increment index of smaller element\n      i++;\n      swap(arr, i, j);\n    }\n  }\n  swap(arr, i + 1, end);\n\n  return i + 1;\n}\n\nvoid qs(int a[], int start, int end)\n{\n  if (start > end)\n    return;\n\n  int pivot = partition(a, start, end);\n\n  // Sorts elements before the pivot and after the pivot separately\n  qs(a, start, pivot - 1);\n  qs(a, pivot + 1, end);\n}\n\nvoid quickSort(int input[], int size)\n{\n\n  qs(input, 0, size - 1);\n\n  // Prints the sorted array\n  for (int i = 0; i < size; i++)\n    printf(\"%d \", input[i]);\n\n  printf(\"\\n\");\n}\n\nint main()\n{\n  int a[] = {10, 80, 30, 90, 40, 50, 70};\n  printf(\"Input  : \");\n  for (int i = 0; i < 7; i++)\n    printf(\"%d \", a[i]);\n  printf(\"\\n\");\n\n  int n = sizeof(a) / sizeof(a[0]);\n  printf(\"Output : \");\n  quickSort(a, n);\n\n  return 0;\n}\n\n```\n                \n</CodeBlock>\n          \n        "}