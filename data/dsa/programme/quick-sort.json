{"slug":"quick-sort","title":"Quick Sort","description":"QuickSort is a Divide and Conquer algorithm. It picks an element as pivot, and then it partitions the given array around the picked pivot element. In quick sort, a large array is divided into two arrays in which one holds values that are smaller than the specified value (Pivot), and another array holds the values that are greater than the pivot. After that, left and right sub-arrays are also partitioned using the same approach. It will continue until the single element remains in the sub-array.","image":"https://raw.githubusercontent.com/codinasion/codinasion-dsa/master/programme/quick-sort/quick-sort.png","tags":["java","c","cpp","js","py","rs"],"contributors":["anirudhhkashyap","9gl","KacperTKI","sandeepB3","udaybadhe","Pablito2020","Chrisi2209","GKosheev"],"latestUpdateDate":"2022-08-03T12:41:00Z","contentHtml":"<h2>Quick Sort</h2>\n<p>QuickSort is a Divide and Conquer algorithm. It picks an element as pivot, and then it partitions the given array around the picked pivot element. In quick sort, a large array is divided into two arrays in which one holds values that are smaller than the specified value (Pivot), and another array holds the values that are greater than the pivot.</p>\n<p>After that, left and right sub-arrays are also partitioned using the same approach. It will continue until the single element remains in the sub-array.</p>\n<pre><code>Input  : 10 80 30 90 40 50 70\nOutput : 10 30 40 50 70 80 90\n</code></pre>\n<pre><code>Time Complexity : O(n*logn)\n</code></pre>\n<pre><code>Space Complexity : O(n)\n</code></pre>\n<hr>\n<pre><code># Write a programme for quick sort\n\ndef get_middle_value(value0, value1, value2):\n    \"\"\"Returns the value that is in between the other values\"\"\"\n\n    if value1 >= value0 >= value2 or value2 >= value0 >= value1:\n        return value0\n    if value0 >= value1 >= value2 or value2 >= value1 >= value0:\n        return value1\n    return value2\n\n\ndef swap_items(array, index1, index2):\n    \"\"\"Swaps the value of index1 with the value of index2\"\"\"\n\n    array[index1], array[index2] = (\n        array[index2],\n        array[index1],\n    )\n    return array\n\n\ndef quick_sort(array):\n    \"\"\"Sorts an array by increasing values using quick sort.\"\"\"\n\n    # base cases\n    if len(array) == 0 or len(array) == 1:\n        return array\n\n    if len(array) == 2:\n        return array if array[0] &#x3C; array[1] else array[::-1]\n\n    # determine the pivot by taking the middle value of the first, center and last values in the array\n    pivot = get_middle_value(array[0], array[len(array) // 2], array[-1])\n    # temporarily remove the pivot\n    array.remove(pivot)\n\n    # set some values to enter the loop\n    index_item_from_left = 0\n    index_item_from_right = 1\n    first = True\n    while index_item_from_left &#x3C; index_item_from_right:\n        # it should not swap when entering the loop\n        if not first:\n            # swap the items\n            array = swap_items(array, index_item_from_left,\n                               index_item_from_right)\n        else:\n            first = False\n\n        # get item from left\n        # default value to move the pivot farthest to the right\n        index_item_from_left = len(array)\n        for i, item in enumerate(array):\n            if item > pivot:\n                index_item_from_left = i\n                break\n\n        # get item from right\n        # default value to move the pivot farthest to the left\n        index_item_from_right = 0\n        for i, item in enumerate(array[::-1]):\n            if item &#x3C; pivot:\n                # the index has to be reversed because the array is reversed in this loop\n                index_item_from_right = len(array) - 1 - i\n                break\n\n    # now add the pivot back in\n    array.append(pivot)\n    # swap the pivot to the correct place\n    array = swap_items(array, index_item_from_left, len(array) - 1)\n    return quick_sort(array[:index_item_from_left]) + quick_sort(\n        array[index_item_from_left:]\n    )\n\n\nif __name__ == \"__main__\":\n    # example test:\n    import random\n\n    array = []\n    for i in range(20):\n        array.append(random.randint(0, 50))\n    print(f\"Before sort : {array}\")\n    array = quick_sort(array)\n    print(f\"After  sort : {array}\")\n\n    last_value = array[0]\n    for i in range(1, len(array)):\n        if array[i] &#x3C; array[i - 1]:\n            raise ValueError(\"Wrong result\")\n\n</code></pre>\n<pre><code>// Write a programme for quick sort\r\n#include &#x3C;iostream>\r\n\r\nvoid swap(int *array, int index1, int index2);\r\nint partition(int *array, int lowIndex, int highIndex, int pivot);\r\nvoid quickSort(int *array, int lowIndex, int highIndex);\r\nvoid printArray(int *array, int size);\r\n\r\nint main()\r\n{\r\n    int pArray[] = {5, 4, 1, 6, 2};\r\n    int size = sizeof(pArray) / sizeof(pArray[0]);\r\n    printf(\"Before Sorting : \");\r\n    printArray(pArray, size);\r\n\r\n    quickSort(pArray, 0, size - 1);\r\n    printf(\"After  Sorting : \");\r\n    printArray(pArray, size);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid printArray(int *array, int size)\r\n{\r\n    for (int i = 0; i &#x3C; size; i++)\r\n    {\r\n        std::cout &#x3C;&#x3C; array[i] &#x3C;&#x3C; \" \";\r\n    }\r\n    std::cout &#x3C;&#x3C; '\\n';\r\n}\r\n\r\nvoid quickSort(int *array, int lowIndex, int highIndex)\r\n{\r\n    // base case for recursion\r\n    if (lowIndex >= highIndex)\r\n        return;\r\n\r\n    // the pivot is set to the last element\r\n    int pivot = array[highIndex];\r\n\r\n    int pLeft = partition(array, lowIndex, highIndex, pivot);\r\n\r\n    // once the pointers have met, we sort the subarrays to the left and right side of the pivot\r\n    quickSort(array, lowIndex, pLeft - 1);\r\n    quickSort(array, pLeft + 1, highIndex);\r\n}\r\n\r\nvoid swap(int *array, int index1, int index2)\r\n{\r\n    int tmp = array[index1];\r\n    array[index1] = array[index2];\r\n    array[index2] = tmp;\r\n}\r\n\r\nint partition(int *array, int lowIndex, int highIndex, int pivot)\r\n{\r\n    int pLeft = lowIndex;\r\n    int pRight = highIndex - 1;\r\n\r\n    while (pLeft &#x3C; pRight)\r\n    {\r\n        // look for a left pointer, which is bigger than the pivot value\r\n        // breaks when the right pointer is met as well\r\n        while (array[pLeft] &#x3C;= pivot &#x26;&#x26; pLeft &#x3C; pRight)\r\n        {\r\n            pLeft++;\r\n        }\r\n        // look for a right pointer, which is smaller than the pivot value\r\n        // breaks when the left pointer is met as well\r\n        while (array[pRight] >= pivot &#x26;&#x26; pRight > pLeft)\r\n        {\r\n            pRight--;\r\n        }\r\n\r\n        // swap the elements, so that bigger elements are on the right side of the pivot and the smaller ones on the left\r\n        swap(array, pLeft, pRight);\r\n    }\r\n\r\n    // this prevents the last element to potentially being out of order\r\n    if (array[pLeft] > array[highIndex])\r\n    {\r\n        // once the pointers meet, then we swap the element with the pivot\r\n        swap(array, pLeft, highIndex);\r\n    }\r\n    else\r\n    {\r\n        pLeft = highIndex;\r\n    }\r\n\r\n    // at this point the pivot stands on the index where the left and right pointers met\r\n    return pLeft;\r\n}\r\n\n</code></pre>\n<pre><code>// Write a programme for quick sort\n\nfunction swap(arr, i, j) {\n  const temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}\n\nfunction partition(arr, left, right) {\n  const temp = arr[left];\n  let swapIndex = left;\n\n  for (let i = left + 1; i &#x3C;= right; i++) {\n    if (temp > arr[i]) {\n      swapIndex++;\n      if (i !== swapIndex) swap(arr, swapIndex, i);\n    }\n  }\n\n  if (swapIndex !== left) swap(arr, swapIndex, left);\n\n  return swapIndex;\n}\n\nfunction quickSort(arr, left = 0, right = arr.length - 1) {\n  if (left >= right) return;\n\n  let pivot = partition(arr, left, right);\n\n  quickSort(arr, left, pivot - 1);\n  quickSort(arr, pivot + 1, right);\n  return arr;\n}\n\nlet a = [5, 4, 1, 6, 2];\n\nconsole.log(\"Before Sort : \" + a);\nquickSort(a);\nconsole.log(\"After  Sort : \" + a);\n\n</code></pre>\n<pre><code>// Write a programme for Quick sort\nimport java.util.Arrays;\n\npublic class QuickSort {\n\n  public static void main(String[] args) {\n    int[] arr = { 5, 4, 1, 6, 2 };\n    System.out.println(\"Before Sorting : \" + Arrays.toString(arr));\n    System.out.print(\"After  Sorting : \");\n    quickSort(arr, 0, arr.length - 1);\n    print(arr);\n  }\n\n  public static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  public static int partition(int[] arr, int low, int high) {\n    int pivot = arr[high];\n\n    int i = (low - 1);\n\n    for (int j = low; j &#x3C;= high - 1; j++) {\n      if (arr[j] &#x3C; pivot) {\n        i++;\n        swap(arr, i, j);\n      }\n    }\n    swap(arr, i + 1, high);\n    return (i + 1);\n  }\n\n  public static void quickSort(int[] arr, int low, int high) {\n    if (low &#x3C; high) {\n      int pi = partition(arr, low, high);\n      quickSort(arr, low, pi - 1);\n      quickSort(arr, pi + 1, high);\n    }\n  }\n\n  public static void print(int[] arr) {\n    System.out.println(Arrays.toString(arr));\n  }\n}\n\n</code></pre>\n<pre><code>fn main() {\n    let x = &#x26;mut [5, 4, 1, 6, 2];\n    quicksort(x);\n    assert_eq!(&#x26;mut [1, 2, 4, 5, 6], x);\n\n    let mut x: Vec&#x3C;i32> = vec![];\n    quicksort(&#x26;mut x);\n    let empty: Vec&#x3C;i32> = vec![];\n    assert_eq!(empty , x);\n\n    let x = &#x26;mut['p', 'c', 'a', 'b'];\n    quicksort(x);\n    assert_eq!(&#x26;mut['a', 'b', 'c', 'p'] , x);\n\n    let x = &#x26;mut[\"pablo\", \"fraile\", \"alonso\"];\n    quicksort(x);\n    assert_eq!(&#x26;mut[\"alonso\", \"fraile\", \"pablo\"] , x);\n}\n\nfn quicksort&#x3C;T>(array: &#x26;mut [T]) where T: PartialEq + Eq + PartialOrd + Clone { \n    let len = array.len();\n    if len &#x3C;= 1 {\n        return;\n    }\n    let initial_pivot_position = choose_pivot_position(0, len);\n    let pivot_value = array[initial_pivot_position].clone();\n    array.swap(initial_pivot_position, len - 1);\n    let final_pivot_position = partition(&#x26;mut array[.. len - 1], &#x26;pivot_value);\n    array.swap(final_pivot_position, len - 1);\n    quicksort(&#x26;mut array[..final_pivot_position]);\n    quicksort(&#x26;mut array[final_pivot_position + 1..]);\n}\n\nfn choose_pivot_position(initial: usize, end: usize) -> usize {\n    initial + (end - initial) / 2\n}\n\nfn partition&#x3C;T>(array: &#x26;mut[T], pivot_value: &#x26;T) -> usize where T: PartialEq + Eq + PartialOrd {\n    let mut smaller_number_index = 0;\n    for i in 0..array.len() { \n        if pivot_value > &#x26;array[i] {\n            array.swap(i, smaller_number_index);\n            smaller_number_index += 1;\n        }\n    }\n    smaller_number_index\n}\n\n</code></pre>\n<pre><code>// Write a programme for quick sort\n#include &#x3C;stdio.h>\n\n// Utility function to swap array elements\nvoid swap(int a[], int i, int j)\n{\n  int t = a[i];\n  a[i] = a[j];\n  a[j] = t;\n}\n\nint partition(int arr[], int start, int end)\n{\n  // initialise last element as pivot\n  int x = arr[end];\n  int i = start - 1, temp;\n\n  for (int j = start; j &#x3C;= end - 1; j++)\n  {\n    // if current element is smaller than pivot\n    if (arr[j] &#x3C; x)\n    {\n      // increment index of smaller element\n      i++;\n      swap(arr, i, j);\n    }\n  }\n  swap(arr, i + 1, end);\n\n  return i + 1;\n}\n\nvoid qs(int a[], int start, int end)\n{\n  if (start > end)\n    return;\n\n  int pivot = partition(a, start, end);\n\n  // Sorts elements before the pivot and after the pivot separately\n  qs(a, start, pivot - 1);\n  qs(a, pivot + 1, end);\n}\n\nvoid quickSort(int input[], int size)\n{\n\n  qs(input, 0, size - 1);\n\n  // Prints the sorted array\n  for (int i = 0; i &#x3C; size; i++)\n    printf(\"%d \", input[i]);\n\n  printf(\"\\n\");\n}\n\nint main()\n{\n  int a[] = {10, 80, 30, 90, 40, 50, 70};\n  printf(\"Input  : \");\n  for (int i = 0; i &#x3C; 7; i++)\n    printf(\"%d \", a[i]);\n  printf(\"\\n\");\n\n  int n = sizeof(a) / sizeof(a[0]);\n  printf(\"Output : \");\n  quickSort(a, n);\n\n  return 0;\n}\n\n</code></pre>\n","markdown":"\n## Quick Sort\n\nQuickSort is a Divide and Conquer algorithm. It picks an element as pivot, and then it partitions the given array around the picked pivot element. In quick sort, a large array is divided into two arrays in which one holds values that are smaller than the specified value (Pivot), and another array holds the values that are greater than the pivot.\n\nAfter that, left and right sub-arrays are also partitioned using the same approach. It will continue until the single element remains in the sub-array.\n\n```txt\nInput  : 10 80 30 90 40 50 70\nOutput : 10 30 40 50 70 80 90\n```\n\n```txt\nTime Complexity : O(n*logn)\n```\n\n```txt\nSpace Complexity : O(n)\n```\n\n---\n\n\n<CodeBlock>\n        \n```python\n# Write a programme for quick sort\n\ndef get_middle_value(value0, value1, value2):\n    \"\"\"Returns the value that is in between the other values\"\"\"\n\n    if value1 >= value0 >= value2 or value2 >= value0 >= value1:\n        return value0\n    if value0 >= value1 >= value2 or value2 >= value1 >= value0:\n        return value1\n    return value2\n\n\ndef swap_items(array, index1, index2):\n    \"\"\"Swaps the value of index1 with the value of index2\"\"\"\n\n    array[index1], array[index2] = (\n        array[index2],\n        array[index1],\n    )\n    return array\n\n\ndef quick_sort(array):\n    \"\"\"Sorts an array by increasing values using quick sort.\"\"\"\n\n    # base cases\n    if len(array) == 0 or len(array) == 1:\n        return array\n\n    if len(array) == 2:\n        return array if array[0] < array[1] else array[::-1]\n\n    # determine the pivot by taking the middle value of the first, center and last values in the array\n    pivot = get_middle_value(array[0], array[len(array) // 2], array[-1])\n    # temporarily remove the pivot\n    array.remove(pivot)\n\n    # set some values to enter the loop\n    index_item_from_left = 0\n    index_item_from_right = 1\n    first = True\n    while index_item_from_left < index_item_from_right:\n        # it should not swap when entering the loop\n        if not first:\n            # swap the items\n            array = swap_items(array, index_item_from_left,\n                               index_item_from_right)\n        else:\n            first = False\n\n        # get item from left\n        # default value to move the pivot farthest to the right\n        index_item_from_left = len(array)\n        for i, item in enumerate(array):\n            if item > pivot:\n                index_item_from_left = i\n                break\n\n        # get item from right\n        # default value to move the pivot farthest to the left\n        index_item_from_right = 0\n        for i, item in enumerate(array[::-1]):\n            if item < pivot:\n                # the index has to be reversed because the array is reversed in this loop\n                index_item_from_right = len(array) - 1 - i\n                break\n\n    # now add the pivot back in\n    array.append(pivot)\n    # swap the pivot to the correct place\n    array = swap_items(array, index_item_from_left, len(array) - 1)\n    return quick_sort(array[:index_item_from_left]) + quick_sort(\n        array[index_item_from_left:]\n    )\n\n\nif __name__ == \"__main__\":\n    # example test:\n    import random\n\n    array = []\n    for i in range(20):\n        array.append(random.randint(0, 50))\n    print(f\"Before sort : {array}\")\n    array = quick_sort(array)\n    print(f\"After  sort : {array}\")\n\n    last_value = array[0]\n    for i in range(1, len(array)):\n        if array[i] < array[i - 1]:\n            raise ValueError(\"Wrong result\")\n\n```\n                \n```cpp\n// Write a programme for quick sort\r\n#include <iostream>\r\n\r\nvoid swap(int *array, int index1, int index2);\r\nint partition(int *array, int lowIndex, int highIndex, int pivot);\r\nvoid quickSort(int *array, int lowIndex, int highIndex);\r\nvoid printArray(int *array, int size);\r\n\r\nint main()\r\n{\r\n    int pArray[] = {5, 4, 1, 6, 2};\r\n    int size = sizeof(pArray) / sizeof(pArray[0]);\r\n    printf(\"Before Sorting : \");\r\n    printArray(pArray, size);\r\n\r\n    quickSort(pArray, 0, size - 1);\r\n    printf(\"After  Sorting : \");\r\n    printArray(pArray, size);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid printArray(int *array, int size)\r\n{\r\n    for (int i = 0; i < size; i++)\r\n    {\r\n        std::cout << array[i] << \" \";\r\n    }\r\n    std::cout << '\\n';\r\n}\r\n\r\nvoid quickSort(int *array, int lowIndex, int highIndex)\r\n{\r\n    // base case for recursion\r\n    if (lowIndex >= highIndex)\r\n        return;\r\n\r\n    // the pivot is set to the last element\r\n    int pivot = array[highIndex];\r\n\r\n    int pLeft = partition(array, lowIndex, highIndex, pivot);\r\n\r\n    // once the pointers have met, we sort the subarrays to the left and right side of the pivot\r\n    quickSort(array, lowIndex, pLeft - 1);\r\n    quickSort(array, pLeft + 1, highIndex);\r\n}\r\n\r\nvoid swap(int *array, int index1, int index2)\r\n{\r\n    int tmp = array[index1];\r\n    array[index1] = array[index2];\r\n    array[index2] = tmp;\r\n}\r\n\r\nint partition(int *array, int lowIndex, int highIndex, int pivot)\r\n{\r\n    int pLeft = lowIndex;\r\n    int pRight = highIndex - 1;\r\n\r\n    while (pLeft < pRight)\r\n    {\r\n        // look for a left pointer, which is bigger than the pivot value\r\n        // breaks when the right pointer is met as well\r\n        while (array[pLeft] <= pivot && pLeft < pRight)\r\n        {\r\n            pLeft++;\r\n        }\r\n        // look for a right pointer, which is smaller than the pivot value\r\n        // breaks when the left pointer is met as well\r\n        while (array[pRight] >= pivot && pRight > pLeft)\r\n        {\r\n            pRight--;\r\n        }\r\n\r\n        // swap the elements, so that bigger elements are on the right side of the pivot and the smaller ones on the left\r\n        swap(array, pLeft, pRight);\r\n    }\r\n\r\n    // this prevents the last element to potentially being out of order\r\n    if (array[pLeft] > array[highIndex])\r\n    {\r\n        // once the pointers meet, then we swap the element with the pivot\r\n        swap(array, pLeft, highIndex);\r\n    }\r\n    else\r\n    {\r\n        pLeft = highIndex;\r\n    }\r\n\r\n    // at this point the pivot stands on the index where the left and right pointers met\r\n    return pLeft;\r\n}\r\n\n```\n                \n```js\n// Write a programme for quick sort\n\nfunction swap(arr, i, j) {\n  const temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}\n\nfunction partition(arr, left, right) {\n  const temp = arr[left];\n  let swapIndex = left;\n\n  for (let i = left + 1; i <= right; i++) {\n    if (temp > arr[i]) {\n      swapIndex++;\n      if (i !== swapIndex) swap(arr, swapIndex, i);\n    }\n  }\n\n  if (swapIndex !== left) swap(arr, swapIndex, left);\n\n  return swapIndex;\n}\n\nfunction quickSort(arr, left = 0, right = arr.length - 1) {\n  if (left >= right) return;\n\n  let pivot = partition(arr, left, right);\n\n  quickSort(arr, left, pivot - 1);\n  quickSort(arr, pivot + 1, right);\n  return arr;\n}\n\nlet a = [5, 4, 1, 6, 2];\n\nconsole.log(\"Before Sort : \" + a);\nquickSort(a);\nconsole.log(\"After  Sort : \" + a);\n\n```\n                \n```java\n// Write a programme for Quick sort\nimport java.util.Arrays;\n\npublic class QuickSort {\n\n  public static void main(String[] args) {\n    int[] arr = { 5, 4, 1, 6, 2 };\n    System.out.println(\"Before Sorting : \" + Arrays.toString(arr));\n    System.out.print(\"After  Sorting : \");\n    quickSort(arr, 0, arr.length - 1);\n    print(arr);\n  }\n\n  public static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  public static int partition(int[] arr, int low, int high) {\n    int pivot = arr[high];\n\n    int i = (low - 1);\n\n    for (int j = low; j <= high - 1; j++) {\n      if (arr[j] < pivot) {\n        i++;\n        swap(arr, i, j);\n      }\n    }\n    swap(arr, i + 1, high);\n    return (i + 1);\n  }\n\n  public static void quickSort(int[] arr, int low, int high) {\n    if (low < high) {\n      int pi = partition(arr, low, high);\n      quickSort(arr, low, pi - 1);\n      quickSort(arr, pi + 1, high);\n    }\n  }\n\n  public static void print(int[] arr) {\n    System.out.println(Arrays.toString(arr));\n  }\n}\n\n```\n                \n```rust\nfn main() {\n    let x = &mut [5, 4, 1, 6, 2];\n    quicksort(x);\n    assert_eq!(&mut [1, 2, 4, 5, 6], x);\n\n    let mut x: Vec<i32> = vec![];\n    quicksort(&mut x);\n    let empty: Vec<i32> = vec![];\n    assert_eq!(empty , x);\n\n    let x = &mut['p', 'c', 'a', 'b'];\n    quicksort(x);\n    assert_eq!(&mut['a', 'b', 'c', 'p'] , x);\n\n    let x = &mut[\"pablo\", \"fraile\", \"alonso\"];\n    quicksort(x);\n    assert_eq!(&mut[\"alonso\", \"fraile\", \"pablo\"] , x);\n}\n\nfn quicksort<T>(array: &mut [T]) where T: PartialEq + Eq + PartialOrd + Clone { \n    let len = array.len();\n    if len <= 1 {\n        return;\n    }\n    let initial_pivot_position = choose_pivot_position(0, len);\n    let pivot_value = array[initial_pivot_position].clone();\n    array.swap(initial_pivot_position, len - 1);\n    let final_pivot_position = partition(&mut array[.. len - 1], &pivot_value);\n    array.swap(final_pivot_position, len - 1);\n    quicksort(&mut array[..final_pivot_position]);\n    quicksort(&mut array[final_pivot_position + 1..]);\n}\n\nfn choose_pivot_position(initial: usize, end: usize) -> usize {\n    initial + (end - initial) / 2\n}\n\nfn partition<T>(array: &mut[T], pivot_value: &T) -> usize where T: PartialEq + Eq + PartialOrd {\n    let mut smaller_number_index = 0;\n    for i in 0..array.len() { \n        if pivot_value > &array[i] {\n            array.swap(i, smaller_number_index);\n            smaller_number_index += 1;\n        }\n    }\n    smaller_number_index\n}\n\n```\n                \n```c\n// Write a programme for quick sort\n#include <stdio.h>\n\n// Utility function to swap array elements\nvoid swap(int a[], int i, int j)\n{\n  int t = a[i];\n  a[i] = a[j];\n  a[j] = t;\n}\n\nint partition(int arr[], int start, int end)\n{\n  // initialise last element as pivot\n  int x = arr[end];\n  int i = start - 1, temp;\n\n  for (int j = start; j <= end - 1; j++)\n  {\n    // if current element is smaller than pivot\n    if (arr[j] < x)\n    {\n      // increment index of smaller element\n      i++;\n      swap(arr, i, j);\n    }\n  }\n  swap(arr, i + 1, end);\n\n  return i + 1;\n}\n\nvoid qs(int a[], int start, int end)\n{\n  if (start > end)\n    return;\n\n  int pivot = partition(a, start, end);\n\n  // Sorts elements before the pivot and after the pivot separately\n  qs(a, start, pivot - 1);\n  qs(a, pivot + 1, end);\n}\n\nvoid quickSort(int input[], int size)\n{\n\n  qs(input, 0, size - 1);\n\n  // Prints the sorted array\n  for (int i = 0; i < size; i++)\n    printf(\"%d \", input[i]);\n\n  printf(\"\\n\");\n}\n\nint main()\n{\n  int a[] = {10, 80, 30, 90, 40, 50, 70};\n  printf(\"Input  : \");\n  for (int i = 0; i < 7; i++)\n    printf(\"%d \", a[i]);\n  printf(\"\\n\");\n\n  int n = sizeof(a) / sizeof(a[0]);\n  printf(\"Output : \");\n  quickSort(a, n);\n\n  return 0;\n}\n\n```\n                \n</CodeBlock>\n          \n        "}